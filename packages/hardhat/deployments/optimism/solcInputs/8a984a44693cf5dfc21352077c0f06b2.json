{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ICERTFACTORY.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface ICERTFACTORY {\n    function completePackage(\n        string memory Name,\n        string memory Symbol,\n        string memory Uri,\n        address _Admin\n    )\n        external\n        returns (\n            address newCertificateAdd,\n            address newSchoolsNFT,\n            address newMentorsSpokAdd\n        );\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nstruct individual {\n    address _address;\n    string _name;\n}\n\ninterface IFACTORY {\n    function register(individual[] calldata _individual) external;\n\n    function revoke(address[] calldata _individual) external;\n}\n"
    },
    "contracts/interfaces/INFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface INFT {\n    function mint(address _to, bytes calldata _daysId, uint256 _amount) external;\n\n    function setDayUri(bytes calldata id, string memory _uri) external;\n\n    function batchMintTokens(address[] memory users, string memory uri) external;\n}\n"
    },
    "contracts/organizations/organisation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../interfaces/INFT.sol\";\nimport \"../interfaces/IFactory.sol\";\n\ncontract Organisation {\n    /**\n     * ============================================================ *\n     * --------------------- ORGANIZATION RECORD------------------- *\n     * ============================================================ *\n     */\n    string organization;\n    string cohort;\n    string public certiificateURI;\n    address organisationFactory;\n    address public NftContract;\n    address public certificateContract;\n    bool public certificateIssued;\n    string public organisationImageUri;\n    bool public isOngoing = true;\n\n    address public spokContract;\n    string public spokURI;\n\n    bool public spokMinted;\n    mapping(address => bool) requestNameCorrection;\n\n    /**\n     * ============================================================ *\n     * --------------------- ATTENDANCE RECORD--------------------- *\n     * ============================================================ *\n     */\n    bytes[] LectureIdCollection;\n    mapping(bytes => lectureData) lectureInstance;\n    mapping(bytes => bool) lectureIdUsed;\n    struct lectureData {\n        address mentorOnDuty;\n        string topic;\n        string uri;\n        uint attendanceStartTime;\n        uint studentsPresent;\n        bool status;\n    }\n\n    /**\n     * ============================================================ *\n     * --------------------- STUDENTS RECORD------------------- *\n     * ============================================================ *\n     */\n    address[] students;\n    mapping(address => individual) studentsData;\n    mapping(address => uint) indexInStudentsArray;\n    mapping(address => uint) studentsTotalAttendance;\n    mapping(address => bool) isStudent;\n    mapping(address => bytes[]) classesAttended;\n    mapping(address => mapping(bytes => bool)) IndividualAttendanceRecord;\n    string[] resultCid;\n    mapping(uint256 => bool) testIdUsed;\n\n    /**\n     * ============================================================ *\n     * --------------------- STAFFS RECORD------------------------- *\n     * ============================================================ *\n     */\n    address moderator;\n    address mentorOnDuty;\n    address[] mentors;\n    mapping(address => uint) indexInMentorsArray;\n    mapping(address => bytes[]) moderatorsTopic;\n    mapping(address => bool) isStaff;\n    mapping(address => individual) mentorsData;\n    // EVENTS\n    event staffsRegistered(uint noOfStaffs);\n    event nameChangeRequested(address changer);\n    event StaffNamesChanged(uint noOfStaffs);\n    event studentsRegistered(uint noOfStudents);\n    event studentNamesChanged(uint noOfStudents);\n    event attendanceCreated(bytes indexed lectureId, string indexed uri, string topic, address indexed staff);\n    event topicEditted(bytes Id, string oldTopic, string newTopic);\n    event AttendanceSigned(bytes Id, address signer);\n    event Handover(address oldMentor, address newMentor);\n    event attendanceOpened(bytes Id, address mentor);\n    event attendanceClosed(bytes Id, address mentor);\n    event studentsEvicted(uint noOfStudents);\n    event mentorsRemoved(uint noOfStaffs);\n    event newResultUpdated(uint256 testId, address mentor);\n\n    // MODIFIERS\n    modifier onlyModerator() {\n        require(msg.sender == moderator, \"NOT MODERATOR\");\n        _;\n    }\n    modifier onlyMentorOnDuty() {\n        require(msg.sender == mentorOnDuty, \"NOT MODERATOR ON DUTY\");\n        _;\n    }\n    modifier onlyStudents() {\n        require(isStudent[msg.sender] == true, \"NOT A VALID STUDENT\");\n        _;\n    }\n    modifier onlyStudentOrStaff() {\n        require(\n            isStudent[msg.sender] == true || msg.sender == moderator || isStaff[msg.sender] == true,\n            \"NOT ALLOWED TO REQUEST A NAME CHANGE\"\n        );\n        _;\n    }\n    modifier onlyStaff() {\n        require(msg.sender == moderator || isStaff[msg.sender] == true, \"NOT MODERATOR\");\n        _;\n    }\n\n    // ERRORS\n    error lecture_id_already_used();\n    error not_Autorized_Caller();\n    error Invalid_Lecture_Id();\n    error Lecture_id_closed();\n    error Attendance_compilation_started();\n    error Already_Signed_Attendance_For_Id();\n    error already_requested();\n    error not_valid_student();\n    error not_valid_Moderator();\n    error not_valid_lecture_id();\n\n    // @dev: constructor initialization\n    // @params: _organization: Name of company,\n    // @params: _cohort: Name of specific Cohort/ Program,\n    constructor(\n        string memory _organization,\n        string memory _cohort,\n        address _moderator,\n        string memory _adminName,\n        string memory _uri\n    ) {\n        moderator = _moderator;\n        organization = _organization;\n        cohort = _cohort;\n        organisationFactory = msg.sender;\n        mentorOnDuty = _moderator;\n        indexInMentorsArray[_moderator] = mentors.length;\n        mentors.push(_moderator);\n        isStaff[_moderator] = true;\n        mentorsData[_moderator]._address = _moderator;\n        mentorsData[_moderator]._name = _adminName;\n        organisationImageUri = _uri;\n    }\n\n    function initialize(address _NftContract, address _certificateContract, address _spokContract) external {\n        if (msg.sender != organisationFactory) revert not_Autorized_Caller();\n        NftContract = _NftContract;\n        certificateContract = _certificateContract;\n        spokContract = _spokContract;\n    }\n\n    // @dev: Function to register staffs to be called only by the moderator\n    // @params: staffList: An array of structs(individuals) consisting of name and wallet address of staffs.\n    function registerStaffs(individual[] calldata staffList) external onlyModerator {\n        uint staffLength = staffList.length;\n        for (uint i; i < staffLength; i++) {\n            if (isStaff[staffList[i]._address] == false && isStudent[staffList[i]._address] == false) {\n                mentorsData[staffList[i]._address] = staffList[i];\n                isStaff[staffList[i]._address] = true;\n                indexInMentorsArray[staffList[i]._address] = mentors.length;\n                mentors.push(staffList[i]._address);\n            }\n        }\n        // UCHE\n        IFACTORY(organisationFactory).register(staffList);\n        emit staffsRegistered(staffList.length);\n    }\n\n    function TransferOwnership(address newModerator) external onlyModerator {\n        assert(newModerator != address(0));\n        moderator = newModerator;\n    }\n\n    // @dev: Function to register students to be called only by the moderator\n    // @params: _studentList: An array of structs(individuals) consisting of name and wallet address of students.\n    function registerStudents(individual[] calldata _studentList) external onlyModerator {\n        uint studentLength = _studentList.length;\n        for (uint i; i < studentLength; i++) {\n            if (isStudent[_studentList[i]._address] == false && isStaff[_studentList[i]._address] == false) {\n                studentsData[_studentList[i]._address] = _studentList[i];\n                indexInStudentsArray[_studentList[i]._address] = students.length;\n                students.push(_studentList[i]._address);\n                isStudent[_studentList[i]._address] = true;\n            }\n        }\n        // UCHE\n        IFACTORY(organisationFactory).register(_studentList);\n        emit studentsRegistered(_studentList.length);\n    }\n\n    // @dev: Function to request name correction\n    function RequestNameCorrection() external onlyStudentOrStaff {\n        if (requestNameCorrection[msg.sender] == true) revert already_requested();\n        requestNameCorrection[msg.sender] = true;\n        emit nameChangeRequested(msg.sender);\n    }\n\n    function editStudentName(individual[] memory _studentList) external onlyStudentOrStaff {\n        uint studentLength = _studentList.length;\n        for (uint i; i < studentLength; i++) {\n            if (requestNameCorrection[_studentList[i]._address] == true) {\n                studentsData[_studentList[i]._address] = _studentList[i];\n                requestNameCorrection[_studentList[i]._address] = false;\n            }\n        }\n        emit studentNamesChanged(_studentList.length);\n    }\n\n    function editMentorsName(individual[] memory _mentorsList) external onlyStudentOrStaff {\n        uint MentorsLength = _mentorsList.length;\n        for (uint i; i < MentorsLength; i++) {\n            if (requestNameCorrection[_mentorsList[i]._address] == true) {\n                mentorsData[_mentorsList[i]._address] = _mentorsList[i];\n                requestNameCorrection[_mentorsList[i]._address] = false;\n            }\n        }\n        emit StaffNamesChanged(_mentorsList.length);\n    }\n\n    // @dev: Function to Create Id for a particular Lecture Day, this Id is to serve as Nft Id. Only callable by mentor on duty.\n    // @params:  _lectureId: Lecture Id of chaice, selected by mentor on duty.\n    // @params:  _uri: Uri for the particular Nft issued to students that attended class for that day.\n    // @params:  _topic: Topic covered for that particular day, its recorded so as to be displayed on students dashboard.\n    function createAttendance(\n        bytes calldata _lectureId,\n        string calldata _uri,\n        string calldata _topic\n    ) external onlyMentorOnDuty {\n        if (lectureIdUsed[_lectureId] == true) revert lecture_id_already_used();\n        lectureIdUsed[_lectureId] = true;\n        LectureIdCollection.push(_lectureId);\n        lectureInstance[_lectureId].uri = _uri;\n        lectureInstance[_lectureId].topic = _topic;\n        lectureInstance[_lectureId].mentorOnDuty = msg.sender;\n        moderatorsTopic[msg.sender].push(_lectureId);\n\n        // NONSO GENESIS\n        INFT(NftContract).setDayUri(_lectureId, _uri);\n        emit attendanceCreated(_lectureId, _uri, _topic, msg.sender);\n    }\n\n    // @dev: Function to mint spok\n    function mintMentorsSpok(string memory Uri) external onlyModerator {\n        require(spokMinted == false, \"spok already minted\");\n        INFT(spokContract).batchMintTokens(mentors, Uri);\n        spokURI = Uri;\n        spokMinted = true;\n    }\n\n    function editTopic(bytes memory _lectureId, string calldata _topic) external {\n        if (msg.sender != lectureInstance[_lectureId].mentorOnDuty) revert not_Autorized_Caller();\n        if (lectureInstance[_lectureId].attendanceStartTime != 0) revert Attendance_compilation_started();\n        string memory oldTopic = lectureInstance[_lectureId].topic;\n        lectureInstance[_lectureId].topic = _topic;\n        emit topicEditted(_lectureId, oldTopic, _topic);\n    }\n\n    function signAttendance(bytes memory _lectureId) external onlyStudents {\n        if (lectureIdUsed[_lectureId] == false) revert Invalid_Lecture_Id();\n        if (lectureInstance[_lectureId].status == false) revert Lecture_id_closed();\n        if (IndividualAttendanceRecord[msg.sender][_lectureId] == true) revert Already_Signed_Attendance_For_Id();\n        if (lectureInstance[_lectureId].attendanceStartTime == 0) {\n            lectureInstance[_lectureId].attendanceStartTime = block.timestamp;\n        }\n        IndividualAttendanceRecord[msg.sender][_lectureId] = true;\n        studentsTotalAttendance[msg.sender] = studentsTotalAttendance[msg.sender] + 1;\n        lectureInstance[_lectureId].studentsPresent = lectureInstance[_lectureId].studentsPresent + 1;\n        classesAttended[msg.sender].push(_lectureId);\n\n        // NONSO GENESIS\n        INFT(NftContract).mint(msg.sender, _lectureId, 1);\n        emit AttendanceSigned(_lectureId, msg.sender);\n    }\n\n    // @dev Function for mentors to hand over to the next mentor to take the class\n\n    function mentorHandover(address newMentor) external {\n        if (msg.sender != mentorOnDuty && msg.sender != moderator) revert not_Autorized_Caller();\n        mentorOnDuty = newMentor;\n        emit Handover(msg.sender, newMentor);\n    }\n\n    function openAttendance(bytes calldata _lectureId) external onlyMentorOnDuty {\n        if (lectureIdUsed[_lectureId] == false) revert Invalid_Lecture_Id();\n        if (lectureInstance[_lectureId].status == true) revert(\"Attendance already open\");\n        if (msg.sender != lectureInstance[_lectureId].mentorOnDuty) revert not_Autorized_Caller();\n\n        lectureInstance[_lectureId].status = true;\n        emit attendanceOpened(_lectureId, msg.sender);\n    }\n\n    function closeAttendance(bytes calldata _lectureId) external onlyMentorOnDuty {\n        if (lectureIdUsed[_lectureId] == false) revert Invalid_Lecture_Id();\n        if (lectureInstance[_lectureId].status == false) revert(\"Attendance already closed\");\n        if (msg.sender != lectureInstance[_lectureId].mentorOnDuty) revert not_Autorized_Caller();\n\n        lectureInstance[_lectureId].status = false;\n        emit attendanceClosed(_lectureId, msg.sender);\n    }\n\n    function RecordResults(uint256 testId, string calldata _resultCid) external onlyMentorOnDuty {\n        require(testIdUsed[testId] == false, \"TEST ID ALREADY USED\");\n        testIdUsed[testId] = true;\n        resultCid.push(_resultCid);\n        emit newResultUpdated(testId, msg.sender);\n    }\n\n    function getResultCid() external view returns (string[] memory) {\n        return resultCid;\n    }\n\n    function EvictStudents(address[] calldata studentsToRevoke) external onlyModerator {\n        uint studentsToRevokeList = studentsToRevoke.length;\n        for (uint i; i < studentsToRevokeList; i++) {\n            delete studentsData[studentsToRevoke[i]];\n\n            students[indexInStudentsArray[studentsToRevoke[i]]] = students[students.length - 1];\n            students.pop();\n            isStudent[studentsToRevoke[i]] = false;\n        }\n\n        // UCHE\n        IFACTORY(organisationFactory).revoke(studentsToRevoke);\n        emit studentsEvicted(studentsToRevoke.length);\n    }\n\n    function removeMentor(address[] calldata rouge_mentors) external onlyModerator {\n        uint mentorsRouge = rouge_mentors.length;\n        for (uint i; i < mentorsRouge; i++) {\n            delete mentorsData[rouge_mentors[i]];\n            mentors[indexInMentorsArray[rouge_mentors[i]]] = mentors[mentors.length - 1];\n            mentors.pop();\n            isStaff[rouge_mentors[i]] = false;\n        }\n        IFACTORY(organisationFactory).revoke(rouge_mentors);\n        emit mentorsRemoved(rouge_mentors.length);\n    }\n\n    function getNameArray(address[] calldata _students) external view returns (string[] memory) {\n        string[] memory Names = new string[](_students.length);\n        string memory emptyName;\n        for (uint i = 0; i < _students.length; i++) {\n            if (\n                keccak256(abi.encodePacked(studentsData[_students[i]]._name)) == keccak256(abi.encodePacked(emptyName))\n            ) {\n                Names[i] = \"UNREGISTERED\";\n            } else {\n                Names[i] = studentsData[_students[i]]._name;\n            }\n        }\n        return Names;\n    }\n\n    function MintCertificate(string memory Uri) external onlyModerator {\n        require(certificateIssued == false, \"certificate already issued\");\n        INFT(certificateContract).batchMintTokens(students, Uri);\n        certiificateURI = Uri;\n        certificateIssued = true;\n    }\n\n    //VIEW FUNCTION\n    function liststudents() external view returns (address[] memory) {\n        return students;\n    }\n\n    function VerifyStudent(address _student) external view returns (bool) {\n        return isStudent[_student];\n    }\n\n    function getStudentName(address _student) external view returns (string memory name) {\n        if (isStudent[_student] == false) revert not_valid_student();\n        return studentsData[_student]._name;\n    }\n\n    function getStudentAttendanceRatio(address _student) external view returns (uint attendace, uint TotalClasses) {\n        if (isStudent[_student] == false) revert not_valid_student();\n        attendace = studentsTotalAttendance[_student];\n        TotalClasses = LectureIdCollection.length;\n    }\n\n    function getStudentsPresent(bytes memory _lectureId) external view returns (uint) {\n        return lectureInstance[_lectureId].studentsPresent;\n    }\n\n    function listClassesAttended(address _student) external view returns (bytes[] memory) {\n        if (isStudent[_student] == false) revert not_valid_student();\n        return classesAttended[_student];\n    }\n\n    function getLectureIds() external view returns (bytes[] memory) {\n        return LectureIdCollection;\n    }\n\n    function getLectureData(bytes calldata _lectureId) external view returns (lectureData memory) {\n        if (lectureIdUsed[_lectureId] == false) revert not_valid_lecture_id();\n        return lectureInstance[_lectureId];\n    }\n\n    function listMentors() external view returns (address[] memory) {\n        return mentors;\n    }\n\n    function VerifyMentor(address _mentor) external view returns (bool) {\n        return isStaff[_mentor];\n    }\n\n    function getMentorsName(address _Mentor) external view returns (string memory name) {\n        if (isStaff[_Mentor] == false) revert not_valid_Moderator();\n        return mentorsData[_Mentor]._name;\n    }\n\n    function getClassesTaugth(address _Mentor) external view returns (bytes[] memory) {\n        if (isStaff[_Mentor] == false) revert not_valid_Moderator();\n        return moderatorsTopic[_Mentor];\n    }\n\n    function getMentorOnDuty() external view returns (address) {\n        return mentorOnDuty;\n    }\n\n    function getModerator() external view returns (address) {\n        return moderator;\n    }\n\n    function getOrganizationName() external view returns (string memory) {\n        return organization;\n    }\n\n    function getCohortName() external view returns (string memory) {\n        return cohort;\n    }\n\n    function getOrganisationImageUri() external view returns (string memory) {\n        return organisationImageUri;\n    }\n\n    function toggleOrganizationStatus() external {\n        isOngoing = !isOngoing;\n    }\n\n    function getOrganizationStatus() external view returns (bool) {\n        return isOngoing;\n    }\n}\n"
    },
    "contracts/organizations/organisationFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./organisation.sol\";\nimport \"../interfaces/ICERTFACTORY.sol\";\n\ncontract EdumateFactory {\n    address public Admin;\n    address organisationAdmin;\n    address certificateFactory;\n    address[] public Organisations;\n    mapping(address => bool) public validOrganisation;\n\n    mapping(address => mapping(address => uint)) public studentOrganisationIndex;\n    mapping(address => address[]) public memberOrganisations;\n    mapping(address => bool) public uniqueStudent;\n    uint public totalUsers;\n\n    constructor(address certFactory) {\n        Admin = msg.sender;\n        certificateFactory = certFactory;\n    }\n\n    function createorganisation(\n        string memory _organisation,\n        string memory _cohort,\n        string memory _uri,\n        string memory _adminName\n    ) external returns (address eduOrganisation, address Nft, address mentorsSpok, address certificate) {\n        organisationAdmin = msg.sender;\n        Organisation organisationAddress = new Organisation(\n            _organisation,\n            _cohort,\n            organisationAdmin,\n            _adminName,\n            _uri\n        );\n        Organisations.push(address(organisationAddress));\n        validOrganisation[address(organisationAddress)] = true;\n        (address CertificateAddr, address AttendanceAddr, address mentorsSpokAddr) = ICERTFACTORY(certificateFactory)\n            .completePackage(_organisation, _cohort, _uri, address(organisationAddress));\n\n        organisationAddress.initialize(address(AttendanceAddr), address(mentorsSpokAddr), address(CertificateAddr));\n        uint orgLength = memberOrganisations[msg.sender].length;\n        studentOrganisationIndex[msg.sender][address(organisationAddress)] = orgLength;\n        memberOrganisations[msg.sender].push(address(organisationAddress));\n\n        Nft = address(AttendanceAddr);\n        certificate = address(CertificateAddr);\n        mentorsSpok = address(mentorsSpokAddr);\n        eduOrganisation = address(organisationAddress);\n\n        return (eduOrganisation, Nft, mentorsSpok, certificate);\n    }\n\n    function register(individual[] calldata _individual) public {\n        require(validOrganisation[msg.sender] == true, \"unauthorized Operation\");\n        uint individualLength = _individual.length;\n        for (uint i; i < individualLength; i++) {\n            address uniqueStudentAddr = _individual[i]._address;\n            uint orgLength = memberOrganisations[uniqueStudentAddr].length;\n            studentOrganisationIndex[uniqueStudentAddr][msg.sender] = orgLength;\n            memberOrganisations[uniqueStudentAddr].push(msg.sender);\n            if (uniqueStudent[uniqueStudentAddr] == false) {\n                totalUsers++;\n                uniqueStudent[uniqueStudentAddr] = true;\n            }\n        }\n    }\n\n    function revoke(address[] calldata _individual) public {\n        require(validOrganisation[msg.sender] == true, \"unauthorized Operation\");\n        uint individualLength = _individual.length;\n        for (uint i; i < individualLength; i++) {\n            address uniqueIndividual = _individual[i];\n            uint organisationIndex = studentOrganisationIndex[uniqueIndividual][msg.sender];\n            uint orgLength = memberOrganisations[uniqueIndividual].length;\n\n            memberOrganisations[uniqueIndividual][organisationIndex] = memberOrganisations[uniqueIndividual][\n                orgLength - 1\n            ];\n            memberOrganisations[uniqueIndividual].pop();\n        }\n    }\n\n    function getOrganizations() public view returns (address[] memory) {\n        return Organisations;\n    }\n\n    function getUserOrganisatons(address _userAddress) public view returns (address[] memory) {\n        return (memberOrganisations[_userAddress]);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}